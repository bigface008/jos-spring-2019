Lab2 Answer

汪喆昊 516030910460 F1603703

Question 1
Assuming that the following JOS kernel code is correct, what type should
variable x have, uintptr_t or physaddr_t?
    mystery_t x;
    char* value = return_a_pointer();
    *value = 10;
    x = (mystery_t) value;
应该是uintptr_t。

Question 2
What entries (rows) in the page directory have been filled in at this point?
What addresses do they map and where do they point? In other words, fill out
this table as much as possible:
+-------+----------------------+---------------------------------------+
| Entry | Base Virtual Address | Points to (logically)                 |
+-------+----------------------+---------------------------------------+
|  1023 |           0xffc00000 | Page table for top 4MB of phys memory |
+-------+----------------------+---------------------------------------+
|  1022 |           0xff800000 | ?                                     |
+-------+----------------------+---------------------------------------+
|     . | ?                    | ?                                     |
+-------+----------------------+---------------------------------------+
|     . | ?                    | ?                                     |
+-------+----------------------+---------------------------------------+
|     . | ?                    | ?                                     |
+-------+----------------------+---------------------------------------+
|     2 |           0x00800000 | ?                                     |
+-------+----------------------+---------------------------------------+
|     1 |           0x00400000 | ?                                     |
+-------+----------------------+---------------------------------------+
|     0 |           0x00000000 | [see next question]                   |
+-------+----------------------+---------------------------------------+

Question 3
(From Lecture 3) We have placed the kernel and user environment in the same
address space. Why will user programs not be able to read or write the kernel's
memory? What specific mechanisms protect the kernel memory?
是因为PTE_U的权限设置。MMU处理虚拟地址到内核地址的访问时会检验该权限位。

Question 4
What is the maximum amount of physical memory that this operating system can
support? Why?
2GB，因为二级页表最大空间为4MB（PTSIZE），0x400000B / sizeof(struct PageInfo) =
0x80000项，每项对应一个4KB的页，则有0x80000 * 0x1000，得到2GB。

Question 5
How much space overhead is there for managing memory, if we actually had the
maximum amount of physical memory? How is this overhead broken down?
我不大明白这个问题的意思......如果overhead是指用来管理内存的内存的话，那么应该包括4K的
page directory、2MB的page table、4MBpages（就是PageInfo的数组），总大小是6MB多一点。
使用大页可以减小pages的长度。

Question 6
Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately
after we turn on paging, EIP is still a low number (a little over 1MB). At what
point do we transition to running at an EIP above KERNBASE? What makes it
possible for us to continue executing at a low EIP between when we enable paging
and when we begin running at an EIP above KERNBASE? Why is this transition
necessary?
在entry.S中的第69行“jmp *%eax”命令后，eip被切换至高地址。之前不切换没有问题是因为第一
次的页表已经开启，低地址的虚拟地址会被解析成相应的物理地址，仍然对应正确的命令。需要切换
是因为接下来需要在高地址干活。
